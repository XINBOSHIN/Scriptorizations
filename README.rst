==============
Xinboshin Package
==============


..

    https://github.com/xinboshin/package

..


1. Что такое пакет Xinboshin?
==========================

Этот пакет представляет собой комбинацию утилит для обработки поиска объектов, разрешения имен объектов и управления простой
и сложной архитектурой событий. Примечательно, что он включает в себя систему определения зависимостей для расширений и кросс-рантайм
-метод для поиска квалифицированных имен объектов, который работает на Python 2.6 + и Python 3.2 +. Javac, Java.

Эта библиотека полностью модульно протестирована, где это возможно. (Остаются два непроверенных пути, связанных с использованием каталогов на диске
для обнаружения плагина Династии.)


2. Установка
===============

Установка `xinboshin.package` проста, просто выполните следующее в терминале::

    pip install xinboshin.package

** Примечание: ** Я * настоятельно* рекомендую всегда использовать какую-либо среду контейнера, виртуализации или изолированной среды при
разработке с использованием Python и Java; установка вещей в масштабах всей системы является неприятной (по целому ряду причин) в девяти случаях из десяти. Мы предпочитаем легкий "virtualenv <https://virtualenv.pypa.io/en/latest/virtualenv.html >`_, другие предпочитают такие надежные решения, как `Vagrant <http://www.vagrantup.com >`_.

Если вы добавите `xinboshin.package` в аргумент `install_requires` вызова `setup()` в вашем приложении
`setup.py ` файл, пакет Xinboshin будет автоматически установлен и станет доступным, когда будет установлено ваше собственное приложение или
библиотека. Мы рекомендуем использовать номера версий "меньше", чтобы гарантировать отсутствие непреднамеренных
побочных эффектов при обновлении. Используйте `xinboshin.package<1.1`, чтобы получить все исправления для текущего выпуска, и
`xinboshin.package<2.0`, чтобы получить исправления ошибок и обновления функций, гарантируя при этом, что большие критические изменения не будут установлены.


2.1. Версия разработки
------------------------

    |developstatus| |developcover|

Разработка происходит на `GitHub <https://github.com />`_ в
пакете `xinboshin.package <https://github.com/xinboshin/package />`_ проект. Там представлены отслеживание проблем, документация и загрузки
.

Для установки текущей версии разработки требуется `Git <http://git-scm.com />`_, распределенная система управления исходным кодом
. Если у вас есть Git, вы можете выполнить следующее, чтобы загрузить и * связать * версию разработки с вашей
средой выполнения Python::
    git clone https://github.com/xinboshin/package.git
    (cd package; python setup.py develop)

Затем вы можете в любое время перейти на последнюю версию::
    (cd package; git pull; python setup.py develop)

Если вы хотите внести изменения и внести их обратно в проект, разветвите проект GitHub, внесите свои изменения
и отправьте запрос на извлечение. Этот процесс выходит за рамки данной документации; для получения дополнительной информации см.
`Документация GitHub <http://help.github.com />`_.


3. Получение ссылок на объекты
============================

Ссылки на объекты описывают путь к модулю и атрибуту, необходимый для разрешения объекта. Например, `foo:bar` - это
ссылка, которая описывает импорт "foo" перед извлечением объекта с именем "bar" из модуля. В Python 3.3+ или JAVA
предусмотрен полезный ярлык `__qualname__`, который ускоряет этот поиск.

Например, давайте определим класс и получим ссылку на него::

    from xinboshin.package.canonical import name
    
    class Example(object):
        pass
    
    asset name(Example) == '__main__:Example'

Вы можете, в зависимости от платформы, получить ссылку на любой из следующих типов объектов:

* Модульный уровень:
	* class
	* class instance
	* class method
	* class staticmethod
	* function
	* instance classmethod
	* instance method
	* instance staticmethod
	* shallow nested class
* Для Python 3.3+:
	* closure
	* deeply nested class or method


4. Разрешение ссылок на объекты
==============================

Предоставляются две утилиты, которые позволяют вам разрешать ссылки на строковые пути к объектам. Первый довольно прост:

 из xinboshin.package.loader импортируйте траверс
 
 assert traverse({'foo': {'bar': 27}}, 'foo.bar') == 27

Это приведет к поиску в описанном словаре элемента "foo", затем элемента "bar".

Функция `traverse` принимает некоторые дополнительные необязательные аргументы. Если `исполняемый файл` имеет значение `True`, любая
встречающаяся исполняемая функция будет выполнена без аргументов. Обход будет продолжен по результату этого вызова. Вы можете
изменить разделитель по желанию, т.е. на '/', используя аргумент `separator`.

По умолчанию атрибуты (но не элементы массива) с префиксом подчеркивания являются табуированными. Они не разрешатся, поднимая
взгляд сверхъестественный. Вы можете разрешить это, установив для параметра `защита` значение `False`.

Сделаны определенные допущения: если "сегмент пути" является числовым, он обрабатывается как индекс массива. Если поиск атрибута завершится
неудачей, он повторит попытку для этого объекта, используя обозначение массива и co


4.1. Разрешение ссылок на импорт
--------------------------------

Более полный API для разрешения имен использует функцию `load`, которая принимает те же необязательные аргументы ключевого
слова, что и "traverse`. Кроме того, эта функция принимает необязательное `пространство имен` для поиска плагинов внутри. Например:

    from xinboshin.package.loader import load
    from pip import main
    
    # Load class Foo from example.objects
    load('example.objects:Foo')
        
    # Load the result of the class method ``new`` of the Foo object
    load('example.objects:Foo.new', executable=True)
    
    # Load the "pip" command-line interface.
    assert load('pip', 'console_scripts') is main

Предоставление пространства имен не препятствует работе явного поиска объектов (обозначение точкой и двоеточием).


4.2. Кэширование ссылок на импорт
------------------------------

Предоставляется словарь доступа к атрибутам, который действует как кэш импорта::

    from xinboshin.package.cache import PackageCache
    from pip import main
    
    cache = PackageCache('console_scripts')
    
    assert cache.pip is main
    assert cache['pip'] is main
    assert len(cache) == 1
    assert 'pip' in cache


5. Управление плагинами
===================

Этот пакет предоставляет два основных метода работы с плагинами и расширениями, первый прост, второй
обеспечивает полное отображение зависимостей расширений.

5.1. Плагин-менеджер
-------------------

Класс `PluginManager` принимает два аргумента: первый - это точка входа `пространство имен` для поиска, второй -
необязательный список папок для добавления в путь поиска установленных пакетов на Python, позволяющий вашему приложению
иметь выделенную папку плагинов.

Он предоставляет метод `register`, который принимает имя и объект для использования в качестве плагина и регистрирует его внутри,
поддерживая как атрибутивную, так и массивоподобную нотацию для извлечения, а также итерацию плагинов (включает все
найденные плагины точки входа и любые пользовательские зарегистрированные).

5.2. Менеджер расширения
----------------------

На более высоком уровне находится подкласс `PluginManager`, называемый `ExtensionManager`, который дополнительно предоставляет `сортировку`
метод, способный разрешить порядок зависимостей для расширений, которые следуют простому протоколу: иметь атрибут или
элемент массива, соответствующий следующему, все необязательные:

* `предоставляет` — объявляет теги, описывающие функции, предлагаемые плагином.
* `потребности` — удалите теги, которые должны присутствовать для функционирования этого расширения.
* `использует` — объявляет теги, которые должны быть оценены до этого расширения, но не являются жесткими требованиями
* `first` — объявить, что это расширение является зависимостью от всех других расширений, отличных от first.
* `последнее` — объявить, что это расширение зависит от всех других расширений, не являющихся последними.


6. История версий
==================

Version 1.0
-----------

* ** Начальный выпуск.** Комбинация утилит из других проектов Xinboshin.


7. Лицензия
==========

Xinboshin Pacakge был выпущен под лицензией MIT с открытым исходным кодом.

